#!/usr/bin/env python3\n\"\"\"\nOffice Converter Security Module\nImplements security controls, sandboxing, and monitoring for office conversions\nMPP-XML Converter Pro - Enterprise Edition\n\"\"\"\n\nimport os\nimport tempfile\nimport subprocess\nimport logging\nimport hashlib\nimport time\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple\nimport resource\nimport signal\nimport psutil\n\nlog = logging.getLogger(\"security.office\")\n\n# Security configuration\nSECURITY_CONFIG = {\n    # File limits\n    'max_file_size': 100 * 1024 * 1024,  # 100MB\n    'max_pages': 500,\n    'max_sheets': 50,\n    'max_slides': 100,\n    \n    # Process limits\n    'timeout_seconds': 300,  # 5 minutes\n    'max_memory_mb': 2048,\n    'max_cpu_percent': 80,\n    'max_processes': 5,\n    \n    # Security scanning\n    'enable_virus_scan': True,\n    'quarantine_suspicious': True,\n    'allowed_extensions': {\n        '.docx', '.doc', '.odt', '.rtf',\n        '.xlsx', '.xls', '.ods', '.csv',\n        '.pptx', '.ppt', '.odp'\n    },\n    \n    # Sandbox\n    'sandbox_enabled': True,\n    'sandbox_tmpdir': '/tmp/office_sandbox',\n    'cleanup_after_conversion': True\n}\n\nclass SecurityError(Exception):\n    \"\"\"Raised when security violation is detected\"\"\"\n    pass\n\nclass OfficeSecurity:\n    \"\"\"Security manager for office document conversions\"\"\"\n    \n    def __init__(self, config: Dict = None):\n        self.config = {**SECURITY_CONFIG, **(config or {})}\n        self.stats = {\n            'files_scanned': 0,\n            'threats_detected': 0,\n            'quarantined_files': 0,\n            'blocked_conversions': 0\n        }\n    \n    def calculate_file_hash(self, file_path: str) -> str:\n        \"\"\"Calculate SHA256 hash of file for integrity verification\"\"\"\n        sha256_hash = hashlib.sha256()\n        with open(file_path, \"rb\") as f:\n            for byte_block in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byte_block)\n        return sha256_hash.hexdigest()\n    \n    def validate_file_structure(self, file_path: str) -> Dict[str, any]:\n        \"\"\"Validate office document structure and extract metadata\"\"\"\n        file_path = Path(file_path)\n        \n        validation_result = {\n            'valid': False,\n            'file_type': None,\n            'size_bytes': 0,\n            'hash': '',\n            'metadata': {},\n            'security_issues': [],\n            'risk_score': 0\n        }\n        \n        try:\n            # Basic file validation\n            if not file_path.exists():\n                raise SecurityError(f\"File not found: {file_path}\")\n            \n            # Check file extension\n            if file_path.suffix.lower() not in self.config['allowed_extensions']:\n                raise SecurityError(f\"File extension not allowed: {file_path.suffix}\")\n            \n            # Check file size\n            file_size = file_path.stat().st_size\n            if file_size > self.config['max_file_size']:\n                raise SecurityError(f\"File too large: {file_size} bytes\")\n            \n            if file_size == 0:\n                raise SecurityError(\"Empty file detected\")\n            \n            # Calculate hash\n            file_hash = self.calculate_file_hash(str(file_path))\n            \n            validation_result.update({\n                'valid': True,\n                'size_bytes': file_size,\n                'hash': file_hash,\n                'file_type': file_path.suffix.lower()\n            })\n            \n            # Check for suspicious patterns in filename\n            suspicious_patterns = ['..', '\\\\', '/', '<', '>', '|', ':', '*', '?', '\"']\n            if any(pattern in file_path.name for pattern in suspicious_patterns):\n                validation_result['security_issues'].append('Suspicious filename pattern')\n                validation_result['risk_score'] += 20\n            \n            # Very basic content validation (can be expanded)\n            with open(file_path, 'rb') as f:\n                header = f.read(100)\n                \n                # Check for common office file signatures\n                office_signatures = {\n                    b'PK\\x03\\x04': 'zip_based_office',  # Modern Office formats\n                    b'\\xd0\\xcf\\x11\\xe0': 'ole_based_office',  # Legacy Office formats\n                    b'%PDF': 'pdf',\n                    b'\\x7fELF': 'executable',  # Suspicious\n                    b'MZ': 'executable'  # Suspicious\n                }\n                \n                for sig, file_type in office_signatures.items():\n                    if header.startswith(sig):\n                        validation_result['metadata']['detected_format'] = file_type\n                        if file_type == 'executable':\n                            validation_result['security_issues'].append('Executable file detected')\n                            validation_result['risk_score'] += 100\n                        break\n            \n            self.stats['files_scanned'] += 1\n            \n        except SecurityError:\n            raise\n        except Exception as e:\n            log.exception(f\"File validation error: {file_path}\")\n            validation_result['security_issues'].append(f\"Validation error: {str(e)}\")\n            validation_result['risk_score'] += 50\n        \n        return validation_result\n    \n    def scan_for_threats(self, file_path: str) -> Dict[str, any]:\n        \"\"\"Scan file for threats using available tools\"\"\"\n        scan_result = {\n            'clean': True,\n            'threats': [],\n            'scanner': 'basic',\n            'scan_time': 0\n        }\n        \n        if not self.config['enable_virus_scan']:\n            return scan_result\n        \n        start_time = time.time()\n        \n        try:\n            # Try to use ClamAV if available\n            if self._is_clamav_available():\n                scan_result = self._scan_with_clamav(file_path)\n            else:\n                # Fallback to basic pattern scanning\n                scan_result = self._basic_threat_scan(file_path)\n            \n            scan_result['scan_time'] = time.time() - start_time\n            \n        except Exception as e:\n            log.error(f\"Threat scanning error: {e}\")\n            scan_result.update({\n                'clean': False,\n                'threats': [f'Scan error: {str(e)}'],\n                'scanner': 'error'\n            })\n        \n        if not scan_result['clean']:\n            self.stats['threats_detected'] += 1\n        \n        return scan_result\n    \n    def _is_clamav_available(self) -> bool:\n        \"\"\"Check if ClamAV is available\"\"\"\n        try:\n            result = subprocess.run(['clamscan', '--version'], \n                                  capture_output=True, timeout=5)\n            return result.returncode == 0\n        except:\n            return False\n    \n    def _scan_with_clamav(self, file_path: str) -> Dict[str, any]:\n        \"\"\"Scan file using ClamAV\"\"\"\n        try:\n            result = subprocess.run(\n                ['clamscan', '--no-summary', '--infected', str(file_path)],\n                capture_output=True,\n                timeout=30,\n                text=True\n            )\n            \n            is_clean = result.returncode == 0\n            threats = []\n            \n            if not is_clean:\n                # Parse ClamAV output for threat names\n                for line in result.stdout.split('\\n'):\n                    if 'FOUND' in line:\n                        threats.append(line.strip())\n            \n            return {\n                'clean': is_clean,\n                'threats': threats,\n                'scanner': 'clamav',\n                'output': result.stdout\n            }\n            \n        except subprocess.TimeoutExpired:\n            raise SecurityError(\"Virus scan timeout\")\n        except Exception as e:\n            raise SecurityError(f\"ClamAV scan failed: {e}\")\n    \n    def _basic_threat_scan(self, file_path: str) -> Dict[str, any]:\n        \"\"\"Basic threat detection without external scanner\"\"\"\n        threats = []\n        \n        try:\n            with open(file_path, 'rb') as f:\n                content = f.read(10000)  # Read first 10KB\n                \n                # Look for suspicious patterns\n                suspicious_patterns = [\n                    b'javascript:',\n                    b'vbscript:',\n                    b'<script',\n                    b'eval(',\n                    b'document.write',\n                    b'ActiveXObject',\n                    b'WScript.Shell',\n                    b'cmd.exe',\n                    b'powershell',\n                    b'\\x00\\x00\\x00\\x00' * 10  # Suspicious null bytes\n                ]\n                \n                for pattern in suspicious_patterns:\n                    if pattern in content.lower():\n                        threats.append(f'Suspicious pattern: {pattern.decode(\"utf-8\", errors=\"ignore\")}')\n            \n        except Exception as e:\n            log.warning(f\"Basic threat scan error: {e}\")\n        \n        return {\n            'clean': len(threats) == 0,\n            'threats': threats,\n            'scanner': 'basic_pattern'\n        }\n    \n    def create_sandbox(self, base_dir: str = None) -> str:\n        \"\"\"Create secure sandbox directory for conversions\"\"\"\n        if not self.config['sandbox_enabled']:\n            return tempfile.mkdtemp(prefix='office_conv_')\n        \n        base_dir = base_dir or self.config['sandbox_tmpdir']\n        \n        # Create sandbox directory structure\n        sandbox_id = hashlib.md5(f\"{time.time()}{os.getpid()}\".encode()).hexdigest()[:8]\n        sandbox_path = os.path.join(base_dir, f'sandbox_{sandbox_id}')\n        \n        os.makedirs(sandbox_path, mode=0o700, exist_ok=True)\n        \n        # Create subdirectories\n        for subdir in ['input', 'output', 'temp', 'logs']:\n            os.makedirs(os.path.join(sandbox_path, subdir), mode=0o700, exist_ok=True)\n        \n        log.info(f\"Created sandbox: {sandbox_path}\")\n        return sandbox_path\n    \n    def set_process_limits(self):\n        \"\"\"Set resource limits for conversion process\"\"\"\n        try:\n            # Memory limit\n            max_memory_bytes = self.config['max_memory_mb'] * 1024 * 1024\n            resource.setrlimit(resource.RLIMIT_AS, (max_memory_bytes, max_memory_bytes))\n            \n            # CPU time limit\n            cpu_limit = self.config['timeout_seconds']\n            resource.setrlimit(resource.RLIMIT_CPU, (cpu_limit, cpu_limit))\n            \n            # Process limit\n            max_procs = self.config['max_processes']\n            resource.setrlimit(resource.RLIMIT_NPROC, (max_procs, max_procs))\n            \n            # File descriptor limit\n            resource.setrlimit(resource.RLIMIT_NOFILE, (100, 200))\n            \n            log.debug(f\"Process limits set: {max_memory_bytes//1024//1024}MB memory, {cpu_limit}s CPU\")\n            \n        except Exception as e:\n            log.warning(f\"Failed to set process limits: {e}\")\n    \n    def monitor_conversion_process(self, pid: int, max_time: int = None) -> Dict[str, any]:\n        \"\"\"Monitor conversion process for security violations\"\"\"\n        max_time = max_time or self.config['timeout_seconds']\n        start_time = time.time()\n        \n        monitoring_result = {\n            'completed': False,\n            'violations': [],\n            'stats': {\n                'max_memory_mb': 0,\n                'max_cpu_percent': 0,\n                'runtime_seconds': 0\n            }\n        }\n        \n        try:\n            process = psutil.Process(pid)\n            \n            while process.is_running() and time.time() - start_time < max_time:\n                try:\n                    # Check memory usage\n                    memory_mb = process.memory_info().rss / 1024 / 1024\n                    monitoring_result['stats']['max_memory_mb'] = max(monitoring_result['stats']['max_memory_mb'], memory_mb)\n                    \n                    if memory_mb > self.config['max_memory_mb']:\n                        monitoring_result['violations'].append(f'Memory limit exceeded: {memory_mb:.1f}MB')\n                        process.terminate()\n                        break\n                    \n                    # Check CPU usage\n                    cpu_percent = process.cpu_percent()\n                    monitoring_result['stats']['max_cpu_percent'] = max(monitoring_result['stats']['max_cpu_percent'], cpu_percent)\n                    \n                    # Check for suspicious child processes\n                    children = process.children(recursive=True)\n                    if len(children) > self.config['max_processes']:\n                        monitoring_result['violations'].append(f'Too many child processes: {len(children)}')\n                        process.terminate()\n                        break\n                    \n                    time.sleep(1)  # Monitor every second\n                    \n                except psutil.NoSuchProcess:\n                    break\n                except Exception as e:\n                    log.warning(f\"Process monitoring error: {e}\")\n                    break\n            \n            # Check if process completed normally\n            if process.is_running():\n                if time.time() - start_time >= max_time:\n                    monitoring_result['violations'].append('Process timeout')\n                    process.terminate()\n                    time.sleep(2)\n                    if process.is_running():\n                        process.kill()\n            else:\n                monitoring_result['completed'] = True\n            \n            monitoring_result['stats']['runtime_seconds'] = time.time() - start_time\n            \n        except psutil.NoSuchProcess:\n            monitoring_result['completed'] = True\n        except Exception as e:\n            log.error(f\"Process monitoring failed: {e}\")\n            monitoring_result['violations'].append(f'Monitoring error: {str(e)}')\n        \n        return monitoring_result\n    \n    def quarantine_file(self, file_path: str, reason: str) -> str:\n        \"\"\"Move suspicious file to quarantine\"\"\"\n        if not self.config['quarantine_suspicious']:\n            return file_path\n        \n        try:\n            quarantine_dir = '/tmp/quarantine'\n            os.makedirs(quarantine_dir, mode=0o700, exist_ok=True)\n            \n            file_hash = self.calculate_file_hash(file_path)\n            quarantine_path = os.path.join(\n                quarantine_dir, \n                f\"{file_hash}_{int(time.time())}.quarantine\"\n            )\n            \n            os.rename(file_path, quarantine_path)\n            \n            # Log quarantine event\n            log.warning(f\"File quarantined: {file_path} -> {quarantine_path} (Reason: {reason})\")\n            \n            self.stats['quarantined_files'] += 1\n            return quarantine_path\n            \n        except Exception as e:\n            log.error(f\"Quarantine failed: {e}\")\n            return file_path\n    \n    def cleanup_sandbox(self, sandbox_path: str):\n        \"\"\"Securely cleanup sandbox directory\"\"\"\n        if not self.config['cleanup_after_conversion']:\n            return\n        \n        try:\n            import shutil\n            shutil.rmtree(sandbox_path)\n            log.debug(f\"Sandbox cleaned up: {sandbox_path}\")\n        except Exception as e:\n            log.warning(f\"Sandbox cleanup failed: {e}\")\n    \n    def get_security_stats(self) -> Dict[str, any]:\n        \"\"\"Get security statistics\"\"\"\n        return {\n            **self.stats,\n            'config': self.config,\n            'timestamp': time.time()\n        }\n\n# Utility functions\ndef secure_office_conversion(converter_func, input_file: str, output_dir: str, \n                           target_format: str, **kwargs) -> Tuple[bool, str]:\n    \"\"\"\n    Wrapper function that adds security to any office conversion function\n    \n    Args:\n        converter_func: The actual conversion function to call\n        input_file: Path to input file\n        output_dir: Output directory\n        target_format: Target format\n        **kwargs: Additional arguments\n        \n    Returns:\n        Tuple[bool, str]: (success, result_or_error)\n    \"\"\"\n    security = OfficeSecurity()\n    \n    try:\n        # Step 1: Validate file structure\n        validation = security.validate_file_structure(input_file)\n        if not validation['valid']:\n            raise SecurityError(f\"File validation failed: {validation['security_issues']}\")\n        \n        # Step 2: Scan for threats\n        scan_result = security.scan_for_threats(input_file)\n        if not scan_result['clean']:\n            quarantine_path = security.quarantine_file(input_file, f\"Threat detected: {scan_result['threats']}\")\n            raise SecurityError(f\"Threat detected: {scan_result['threats']}\")\n        \n        # Step 3: Create sandbox\n        sandbox = security.create_sandbox()\n        \n        # Step 4: Set process limits\n        security.set_process_limits()\n        \n        # Step 5: Perform conversion\n        result = converter_func(input_file, sandbox, target_format, **kwargs)\n        \n        # Step 6: Cleanup\n        security.cleanup_sandbox(sandbox)\n        \n        return result\n        \n    except SecurityError:\n        raise\n    except Exception as e:\n        log.exception(\"Secure conversion error\")\n        return False, str(e)\n\nif __name__ == \"__main__\":\n    # Test security module\n    security = OfficeSecurity()\n    print(\"ðŸ”’ Office Security Module Ready!\")\n    print(f\"ClamAV Available: {security._is_clamav_available()}\")\n    print(f\"Sandbox Enabled: {security.config['sandbox_enabled']}\")\n    print(f\"Max File Size: {security.config['max_file_size']//1024//1024}MB\")\n